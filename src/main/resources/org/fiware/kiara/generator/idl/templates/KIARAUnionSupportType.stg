group KIARAUnionSupportType;

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.currentUnion.name, ".java"], description=["This file contains the class representing a user defined union."])$
package $ctx.javaPackage$;

import org.fiware.kiara.serialization.impl.Serializable;
import org.fiware.kiara.serialization.impl.SerializerImpl;
import org.fiware.kiara.serialization.impl.CDRSerializer;
import org.fiware.kiara.transport.impl.TransportMessage;

import java.util.List;
import java.util.ArrayList;
import java.util.Objects;

public class $ctx.currentUnion.name$ implements Serializable {
	
	private $paramTypeJava(ctx.currentUnion.discriminator)$ m_d;
	
	$ctx.currentUnion.members : {member | private $paramTypeJava(typecode=member.typecode)$ $member.name$;}; separator="\n"$
	
	public $ctx.currentUnion.name$() {
		$ctx.currentUnion.members : {member | this.$member.name$ = $initialize_param(member)$;}; separator="\n"$
	}
	
	$generate_disc_init(ctx)$
	
	$serialization_methods(union=ctx.currentUnion)$
	
	$accessor_methods(ctx.currentUnion)$
	
	$generate_max_serialized_size(ctx.currentUnion)$
	
}
 
>>

get_switch_type(typecode) ::= <<
$if(typecode.type_boolean)$
Boolean bool_disc = this.m_d;
switch(bool_disc.toString()) {
$else$
switch(this.m_d) {
$endif$
>>

generate_disc_init(ctx) ::= <<
public void _d($paramTypeJava(ctx.currentUnion.discriminator)$ discriminator) {
	this.m_d = discriminator;
}
>>

initialize_param(member) ::= <<
$if(member.typecode.isType_a)$new $member.typecode.cppTypename$()
$else$$if(member.typecode.isType_b)$$member.typecode.cppTypename$null
$else$
$if(member.typecode.isType_f)$
null
$else$
$initJava.(member.typecode.stType)$
$endif$
$endif$
$endif$
>>

serialization_methods(union) ::= <<
/*
 * This method serializes the union $union.name$.
 *
 * @see org.fiware.kiara.serialization.impl.Serializable#serialize(org.fiware.kiara.serialization.impl.SerializerImpl, org.fiware.kiara.transport.impl.TransportMessage, java.lang.String)
 */
public void serialize(SerializerImpl impl, TransportMessage message, String name) {
	impl.$serializeJava.(union.discriminator.stType)$(message, name, this.m_d);

	$get_switch_type(union.discriminator)$
$union.members : {member | 
$if(member.labels)$
$member.labels : {label | 	case $if(union.discriminator.type_boolean)$"$endif$$label$$if(union.discriminator.type_boolean)$"$endif$:}; separator="\n"$

$else$
	default:

$endif$
$if(member.typecode.isType_e)$
		impl.$serializeSequenceJava.(member.typecode.contentTypeCode.stType)$(message, name, this.$member.name$);
$else$
$if(member.typecode.isType_f)$
		impl.$serializeArrayJava.(member.typecode.contentTypeCode.stType)$(message, name, this.$member.name$, $member.typecode.dimensions : {dim |$dim$}; separator=", "$);
$else$
		impl.$serializeJava.(member.typecode.stType)$(message, name, this.$member.name$);
$endif$
$endif$

		break;}; separator = "\n"$
	}

}

/*
 * This method deserializes the $union.name$.
 *
 * @see org.fiware.kiara.serialization.impl.Serializable#deserialize(org.fiware.kiara.serialization.impl.SerializerImpl, org.fiware.kiara.transport.impl.TransportMessage, java.lang.String)
 */
public void deserialize(SerializerImpl impl, TransportMessage message, String name) {
	this.m_d = impl.$deserializeJava.(union.discriminator.stType)$(message, name);
	
	$get_switch_type(union.discriminator)$
$union.members : {member |
$if(!member.default)$$if(member.labels)$
	$member.labels : {label |case $if(union.discriminator.type_boolean)$"$endif$$label$$if(union.discriminator.type_boolean)$"$endif$:}; separator="\n"$
$endif$

$deserialize_function_member(member)$
$endif$
}; separator="\n"$
$if(union.defaultvalue)$
$if(union.defaultMember)$
	default:
$deserialize_function_member(union.defaultMember)$
$endif$
$endif$
	
	}

}


>>

deserialize_function_member(member) ::= <<
$if(member.typecode.primitive)$
		this.$member.name$ = impl.$deserializeJava.(member.typecode.stType)$(message, name);
$else$
$if(member.typecode.isType_f)$
$if(!member.typecode.contentTypeCode.primitive)$$if(member.typecode.contentTypeCode.isType_a)$
		try { 
			this.$member.name$ = impl.$deserializeArrayJava.(member.typecode.contentTypeCode.stType)$(message, name$if(!member.typecode.contentTypeCode.primitive)$, $member.typecode.contentTypeCode.cppTypename$.class$endif$, $member.typecode.dimensions : {dim |$dim$}; separator=", "$);
		} catch (InstantiationException | IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
$endif$
$else$
		this.$member.name$ = impl.$deserializeArrayJava.(member.typecode.contentTypeCode.stType)$(message, name$if(!member.typecode.contentTypeCode.primitive)$, $member.typecode.contentTypeCode.cppTypename$.class$endif$, $member.typecode.dimensions : {dim |$dim$}; separator=", "$);
$endif$
$else$
$if(member.typecode.isType_e)$
$if(member.typecode.contentTypeCode.primitive)$
	this.$member.name$ = impl.$deserializeSequenceJava.(member.typecode.contentTypeCode.stType)$(message, name, $member.typecode.depth$);
$else$
$if(!member.typecode.primitive)$$if(member.typecode.isType_e)$
		try { 
$endif$$endif$
			this.$member.name$ = impl.$deserializeSequenceJava.(member.typecode.contentTypeCode.stType)$(message, name, $member.typecode.contentTypeCode.cppTypename$.class, $member.typecode.depth$);
$if(!member.typecode.primitive)$$if(member.typecode.isType_e)$
		} catch (InstantiationException | IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
$endif$$endif$
$endif$
$else$
$if(!member.typecode.primitive)$$if(member.typecode.isType_a)$
		try { 
$endif$$endif$
			this.$member.name$ = impl.$deserializeJava.(member.typecode.stType)$(message, name, $member.typecode.cppTypename$.class);
$if(!member.typecode.primitive)$$if(member.typecode.isType_a)$
		} catch (InstantiationException | IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
$endif$$endif$
$endif$
$endif$
$endif$
		
		break;
$endif$ 
>>

accessor_methods(currentSt) ::= <<
$currentSt.members : {member | 
$if(member.typecode.isType_f)$
/*
 * Method to get the attribute $member.name$.
 */
$if(member.typecode.contentTypeCode.primitive)$
public $member.typecode.cppTypename$ get$member.javaName$() {
$else$
public $arrayAttributeFirst(name=member.name, type=member.typecode, dims=member.typecode.dimensions)$ get$member.javaName$() \{
$endif$ 
	boolean canDoIt = false;
	$if(!member.default)$
	$candoit_switch_case(member=member, typecode=currentSt.discriminator)$
	$else$
	$endif$
	
	if (!canDoIt) {
		throw new UnsupportedOperationException("Invalid union value");
	}
	return this.$member.name$;
}

/*
 * Method to set the attribute $member.javaName$.
 */
$if(member.typecode.contentTypeCode.primitive)$
public void set$member.javaName$($member.typecode.cppTypename$ $member.name$) {

$else$
public void set$member.javaName$($arrayAttributeFirst(name=member.name, type=member.typecode, dims=member.typecode.dimensions)$ $member.name$) \{

$endif$
	boolean canDoIt = false;
	$if(!member.default)$
	$candoit_switch_case(member=member, typecode=currentSt.discriminator)$
	$else$
	$candoit_default_switch_case(union=currentSt, typecode=currentSt.discriminator)$
	$endif$
	
	if (!canDoIt) {
		throw new UnsupportedOperationException("Invalid union value");
	}
	this.$member.name$ = $member.name$;
}
$else$
/*
 * Method to get the attribute $member.name$.
 */
$if(member.typecode.isType_e)$
$if(member.typecode.contentTypeCode.primitive)$
public $paramTypeJava(member.typecode)$ get$member.javaName$() \{

$else$
public $sequenceAttributeFirst(name=member.name, type=member.typecode)$ get$member.javaName$() \{

$endif$
$else$
public $paramTypeJava(member.typecode)$ get$member.javaName$() { 

$endif$
	boolean canDoIt = false;
	$if(!member.default)$
	$candoit_switch_case(member=member, typecode=currentSt.discriminator)$
	$else$
	$candoit_default_switch_case(union=currentSt, typecode=currentSt.discriminator)$
	$endif$
	
	if (!canDoIt) {
		throw new UnsupportedOperationException("Invalid union value");
	}
	return this.$member.name$;
}

/*
 * Method to set the attribute $member.name$.
 */
$if(member.typecode.isType_e)$
$if(member.typecode.contentTypeCode.primitive)$
public void set$member.javaName$($paramTypeJava(member.typecode)$ $member.name$) \{

$else$
public void set$member.javaName$($sequenceAttributeFirst(name=member.name, type=member.typecode)$ $member.name$) \{

$endif$
$else$
public void set$member.javaName$($paramTypeJava(member.typecode)$ $member.name$) {

$endif$
	boolean canDoIt = false;
	$if(!member.default)$
	$candoit_switch_case(member=member, typecode=currentSt.discriminator)$
	$else$
	$candoit_default_switch_case(union=currentSt, typecode=currentSt.discriminator)$
	$endif$
	
	if (!canDoIt) {
		throw new UnsupportedOperationException("Invalid union value");
	}
	this.$member.name$ = $member.name$;
}
$endif$
}; separator="\n"$
>>

candoit_switch_case(member, typecode) ::= <<
$get_switch_type(typecode)$
	$member.labels : {label |case $if(typecode.type_boolean)$"$endif$$label$$if(typecode.type_boolean)$"$endif$:}; separator="\n"$$\n$$print_candoit_case(member)$
	default:
		break;
}
>>

print_candoit_case(member) ::= <<
	canDoIt=true;
	break;
>>

candoit_default_switch_case(union, typecode) ::= <<
$get_switch_type(typecode)$
	$union.members : {member |$if(!member.default)$$member.labels : {label |case $if(typecode.type_boolean)$"$endif$$label$$if(typecode.type_boolean)$"$endif$:}; separator="\n"$$\n$$\t$break;$endif$}; separator="\n"$
	default:
		canDoIt=true;
		break;
}
>>

generate_max_serialized_size(union) ::= <<
/*
 *This method calculates the maximum size in CDR for this class.
 * 
 * @param current_alignment Integer containing the current position in the buffer.
 */
public static int getMaxCdrSerializedSize(int current_alignment)
{
    int current_align = current_alignment;
            
    $union.members : {member |$max_serialized_size(ctx=ctx, typecode=member.typecode, var="current_align", name=member.name)$}; separator="\n"$
 
    return current_align;
}
>>

module(ctx, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

interface(ctx, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$

>>

exception(ctx, exception) ::= <<>>

operation(ctx, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, const) ::= <<>>

typedef_decl(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<>>

union_type(ctx, union) ::= <<>>

enum_type(ctx, enum) ::= <<>>



